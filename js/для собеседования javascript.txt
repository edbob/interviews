//спасибо Брендану Айку!)
<!--
В языке JavaScript все числа хранятся в формате float64(8 байт) 
с плавающей точкой. В этом формате не всегда возможны точные 
вычисления.

JS поддерживает несколько породигм программирования
1: Процедуральная
2: ООП
3: Функциональная 

-->
while -Цикл, с предусловием – это цикл, который выполняется 
до тех пор, 
пока условие удовлетворяет истинности. 
do-while -Цикл, с постусловием  – это цикл, в котором условие
 проверяется
после выполнения тела цикла. 
for  -Цикл со счетчиком – это цикл, в котором переменная –
 счетчик итераций цикла, 
с определенным шагом, изменяет свое значение до заданного
 конечного значения. 
<!--
Объект – это составной тип данных, он объединяет множество
 значений в единый модуль 
и позволяет сохранять и извлекать значения по их именам.
Самым простым способом создания объекта является использование
 конструктора Object()

Ссылка — это средство доступа к объекту под различными именами.
 Работа с любыми объектами ведется исключительно по ссылке.


<!--
Создание объекта через блок инициализации:
var имя_обьекта = { имя_свойства: значение_свойства, имя_свойства: 
значение_свойства }
this всегда относится к «владельцу» выполняемой функции,
или, если быть точнее, к объекту, методом которого является функция.
-->

<!--
Помимо создания объекта через блок инициализации, можно реализовать 
создание через специально предусмотренный конструктор Object().
Конструктор не принимает никаких параметров, 
а перед ним обязательно должно указываться ключевое слово new.

Свойства объекта будут создаваться автоматически при первом обращении 
по имени будущего свойства и присвоения ему значения.
-->

<!--
В объекты можно вкладывать другие объекты, для этого необходимо 
в качестве содержимого свойства поместить описание еще одного объекта.
При обращении к свойствам вложенных объектов необходимо полностью
 указывать путь, например:
human.ocupation.company - обращаемся к свойству company 
объекта ocupation, который вложен в объект human
-->

<!--
Насле́дование — механизм объектно-ориентированного программирования 
(наряду с инкапсуляцией, полиморфизмом и абстракцией),
позволяющий описать новый класс на основе уже существующего 
(родительского), при этом свойства и функциональность 
родительского класса заимствуются новым классом.
Другими словами, класс-наследник реализует спецификацию уже 
существующего класса (базовый класс). 
Это позволяет обращаться с объектами класса-наследника точно 
так же, как с объектами базового класса.prototype
-->

<!--

Инкапсуляция - сокрытие реализации и данных объекта.

Closure Замыкания — это функции, ссылающиеся на независимые (свободные) 
переменные.

Другими словами, функция, определённая в замыкании, «запоминает» 
окружение, в котором она была создана.

Если одна функция вложена в другую функцию, то внутренняя функция 
имеет доступ к локальным переменным
внешней функции. Такая техника называется – захват локальной 
переменной или замыкание (closure).
Есть статическая и денамическая области видимости:
	примеру: 
		let value = 'static';
		function print(){
			consile.log(value);
		}
		(funcrion(fn){
			let value = 'dynamic';
			fn();
		})();
			//в данном случае выведит static
			//если добавить (print)//значение поменяется на dynamic!
Пример Замыкания:
	let todos =[];
	function addTodo(todo){
		todos.push(todo);
	}
	function call(fn, ...args){
		fn(...args);
	}
	call(addTodo, 'разобратся с замыканиями в js');
	//значение: разобратся с замыканиями в js
	еще пример замыкания:
	let addTodo;
	function protectState(){
		let todos = [];

		addTodo =function addTodo(todo){
			todos.posh(todo);
		}
	}
	protectState();
	addTodo('разобратся с замыканиями в js');
	еще:
	let addTodo = (function(){
		let todos = [];
		return function(todo){
			todos.push(todo);
		};
	})();
	addTodo('разобратся с замыканиями в js');
-->

<!--
Полиморфи́зм (в языках программирования) — возможность объектов 
с одинаковой спецификацией иметь различную реализацию.
-->

-->
объект первого класса
First-Class Object
Объект: 
	обозначается: 
	{} - литерал,(у объект есть особая форма которая называется литерал),
	let person = {}; - обект можно поместить в переменную,
	Array.push({});- объект можно перередать в массив,
	window.person = {}; - объект можно указывать в качестве свойства у другово объекта,
	invite({}); - объект можем передать в функции,
	return {}; - объект можем вернуть из функции,
	person.name = 'Brendan'; - и у объект есть свойства.
Функция:
	function(){}- у вункции есть литерал,
	let handler = function(){}; - функцию можно поместить в переменную,
	Array.push(function(){}); - функцию можно поместить в массив,
	button.onclick = function(){};- свойства обекта передать в другую функцию,
	button.onclick(function() {});
	return function() {};- функцию можно вернуть с другой функции
	handler.name = 'handle' - у функции есть свойства

var add = function(x, y){
	return x + t;
}//это называется вырожение функций

function add(){

}//простое объявление функций

	Стрелочные функции(Arrow function) более удобный синтаксис функций.
	обычная функция
	let add = function(x, y){
		return x + y;
	}
	стрелочкая функция
	let add = (x, y) => x + y;
	у стрелочных функций нет доступа к методам call, apply и bind.

Вызов конструктора.(constraction).
	вот так создается функция конструктор: 
	let add = new Function('x', 'y', 'return x + y');
	add(3, 4);
	но считается использования таких функций плохой практикой!

аргументы и параметры.
	function add(x, y){параметры
		return x + y;
	}

	add(1, 2); аргументы
	add(1, 2, 3);лишний аргумент проигнорится
	add();пустой выведется NaN

function add(x = 0, y = 0){параметры
		return x + y;
	}
	add();в этот случае не получим NaN а 0;

псевдо масив arguments(является объектом)
	function add(x,y){
		console.log(arguments);
		return x+y;
	}
	add(1,2,3,4,5)
В ES6 добавили новый параметыр ... три точки
	function add(x, y, ...args){
		console.log(args);

		return x + y;
	}
	add(1,2,3,4,5);

this- определяется согласно таму, как функция вызывается!!!
this-  будет всегда указывать на глобальный обект но в
'use Strict'; будет определятся как undefined!
У функций есть два метода это call и apply!

bind -еще один метод функции котрой привязывает жоско к указаному this
пример:
	function print(){
		console.log(this);
	}
	let printDocument = print.bind(document);
	//printDocument() привызове увидем привязку к обекту docement,
	если попытаемся привязатся орять к window у нас нечего не выйдит!
	printDocument.call(window);//document

Типы свойств объектов:
	Данный://для работы в консоли Object.defineProperty(..., ...){propertys...}
		value: undefined
		writeable: false
		enumerable: false
		configurable: false

	Аксессоры
		enumerable: false
		configurable: false
		get: funcrion
		set: funcrion

метоты get и set
get сробатывает когда запрашиваем что то у обекта
set сробатывает когда что то передоем обекту
<!--
Конструктор Function позволяет динамически создавать и компилировать 
анонимные функции. 
Конструктор Function принимает неограниченное количество параметров,
 последний параметр 
всегда является телом создаваемой функции, параметры, которые 
передаются в начале 
списка аргументов Function, являются входными параметрами для
генерируемой функции.
	
Вложенный объект можно создать с помощью функции конструктора.
-->

<!--
Массив— именованный набор не строго типизированных
переменных, расположенных в памяти непосредственно друг за другом,
 доступ к
которым осуществляется по индексу.
	
одномерных массивов
Массивы бывают одномерными, для этого в каждый элемент массива 
следует 
расположить еще один массив .

JavaScript поддерживает две разновидности массивов :
-Ассоциативный массив (Hash), где данные хранятся по произвольному
 ключу.
-Числовой массив Array, где данные хранятся по номерам.

Ассоциативный массив — структура (или тип) данных, в которой можно
 хранить любые 
данные в формате ключ - значение.
-->

<!--
Функция – это блок программного кода на языке JavaScript, который 
определяется один раз и 
может вызываться многократно.
Функции могут иметь параметры, или аргументы, – локальные переменные,
 значения которых определяются
при вызове функции.

Функция - конструктор – это функция, которая выполняет инициализацию 
свойств объекта 
и предназначена для использования совместно с инструкцией new .

Объект Arguments – это объектное представление массива позволяющего
 извлекать переданные
функции значения по номеру, а не по имени.
Callback- Функция обратного вызова
Ссылка на исполняемый код, или на фрагмент исполняемого кода, 
который передается в качестве аргумента другого кода.
Поднятие переменных или функций — перемещение их интерпретатором 
в начало области видимости.


Объект Promise (обещание) используется для отложенных и асинхронных
 вычислений. Promise может находиться в трёх состояниях:

ожидание (pending): начальное состояние, не выполнено и не отклонено.
выполнено (fulfilled): операция завершена успешно.
отклонено (rejected): операция завершена с ошибкой.
Другой термин, описывающий состояние заданный (settled): 
обещание выполнено или отклонено, 
но не находится в состоянии ожидания.
-->

<!--
Метод прототипа Rectangle будет доступен каждому экземпляру, 
но храниться будет в прототипе соответственно 
занимать меньше места 
чем если бы метод принадлежал каждому экземпляру.
-->

<!--
constructor - свойство, которое хранит ссылку на функцию-конструктор,
 через которую был создан объект.
-->

<!--
instanceof - оператор для проверки типа объекта
-->

<!--
typeof - оператор для получения типа объекта в виде строкового 
значения
-->
toString() – для получение строкового представления объекта 
equals(obj ) – для сравнения объектов по значениям 
compareTo(obj ) – для определения отношения между объектами –
 больше/меньше.
<!--
Метод valueOf() возвращает примитивное значение объекта.
-->

<!--
hasOwnProperty метод из Object с его помощью можно проверить 
существует ли свойство у конкретного объекта не проверяя наличие 
свойств у прототипа.
-->

<!--

Конструкция if(имя свойства in объект) - 
используется для проверки наличия свойства у объекта.
проверка равенства объектов с помощью метода equals
-->

<!--

delete - оператор который способен удалить свойство в объекте, 
для этого необходимо использовать его следующим образом:
delete  имя объекта.имя свойства;

При обращении к свойству впоследствии будет возвращаться undefined.

-->

<!--

Оператор with создает новую область видимости и 
представляет свойства объекта «object» как локальные переменные. 
    
Оператор with является устаревшим и его использование не желательно. 
Его использование запрещено в Strict Mode. Подробнее:
 http://habrahabr.ru/post/118666/

-->

 Что такое - Scope(Область видимости переменной)
Область видимости переменной — понятие в некоторых языках 
программирования. Оно определяет места в исходном коде программы,
 в которых может использоваться данная переменная.

По области видимости переменные делятся на: локальные и глобальные. 
В некоторых языках появились ещё и общие переменные.

Область видимости переменной может задаваться с помощью классов памяти
 или пространства имён.

область видимости используется для определения степени скрытия информации,
то есть видимости или доступности переменных из разных частей программы.

Контекст вызова this, шаблон вызова метода
 - Шаблон вызова конструктора
 - Шаблон вызова функции
 - Шаблон вызова call/apply (непрямой вызов функции)
- Применение непрямого вызова функции
<!--
arguments- Массив Аргументов arguments лучше его рассматривать 
как объект имеющий пронумерованные свойства
видит передаваемые аргументы функции 

Метод call() вызывает функцию с указанным значением this и 
индивидуально предоставленными аргументами.
хотя синтаксис этой функции практически полностью идентичен
 функции apply(), фундаментальное различие 
между ними заключается в том, что функция call() принимает список 
аргументов, в то время,
как функция apply() - одиночный массив аргументов.
	
//call
//1
	var obj = {объявляем объект
  		p: 777,свойство 
  		method: function(a, b){метод принимающий 
два параметра
    		log(this.p, a, b);выводит три параметра с 
помощью call заменяем свойства объекта obj на свойства 
объекта trap и добавляем еще два параметра их можно ставить
 а можно опустить!
  	  }
	};

	var trap = {объект
  		p: "its a trap"свойства
	};

	obj.method.call(trap, 32, 44);
	//метод call ведет себя как кукушка которая 
подкладывает в чужие гнезда свои яйца))
	obj.method.apply(trap, [32, 44]);
	//метод apply() работает точно так же как и 
call за исключением того что параметры передаются в виде массива 
	
	//2
        var obj = { name: 3 };
        function addname(a, b, c) {
            return this.name + a + b + c;
        }
        //console.log(addname.call(obj, 2));
        //apply
        var arr = [2, 2, 4];
        console.log(addname.apply(obj, arr));

	нежелательный контекст вызовов есть лайфхак 
для этого с помощью call() and apply()
	function func() {
  		var arg = [].slice.call(arguments);
  		log(arg, arg instanceof Array);
	}
	func(4, 5, 6, 7, 8, 9, 100);
	в консоли получим значения массива
 [4, 5, 6, 7, 8, 9, 100]true
	если не использовать slice и call получим
{0:4, 1:5, 2:6, 3:7, 4:8, 5:9, 6:100} false
-->

<!--
AngularJS это open - source JavaScript-фреймворк от Google. 
Предназначен в основном для разработки Single Page Application .
SPA- для одностраничных сайтов позволит пользователю быстро 
взаимодействовать с вашим
веб приложением ему придется переходить от страницы к странице
 так как основной принцип это бновление ДОМ дерева 
а не всей HTML страницы целиком!
Его цель — расширение браузерных приложений на основе MVC шаблона,
 а также упрощение тестирования и разработки. 
Фреймворк работает с HTML, содержащим дополнительные пользовательские
 атрибуты, которые описываются директивами,
и связывает ввод или вывод области страницы с моделью, представляющей
 собой обычные переменные JavaScript. 
Значения этих переменных задаются вручную или извлекаются из 
статических или динамических JSON -данных

Twitter Bootstrap — свободный набор инструментов для создания 
веб- приложений. 
Включает в себя HTML и CSS шаблоны оформления для типографики, 
веб-форм, кнопок, меток, 
блоков навигации и прочих компонентов веб- интерфейсов, включая 
JavaScript расширения.
· Основные компоненты Bootstrap: o Сетки — заранее заданные размеры
 колонок, которые можно сразу же 
использовать. o Шаблоны — фиксированный или резиновый шаблон 
документа. o Типографика — описания шрифтов, 
определение некоторых классов для шрифтов, таких как код, цитаты
 и т. п.
o Медиа — представляет некоторое управление изображениями и 
видео. o Таблицы — средства оформления таблиц,
вплоть до добавления функциональности сортировки. o Формы — классы
 для оформления не только форм, но и некоторых событий,
происходящих с ними. o Навигация — классы оформления для табов, 
вкладок, странности, меню и тулбара. 
o Алерты — оформление диалоговых окон, подсказок и всплывающих окон.

-->

        // Методы для работы с DOM
        // appendChild - добавить дочерний элемент
        // insertBefore - добавить элемент перед указанным
        // removeChild - удаление элемента
        // replaceChild - замена одного элемента на другой

        Основные типы узлов
        // Интерфейс           | Константа nodeType            | Значение nodeType
        // ------------------------------------------------------------------------
        // Element             | Node.ELEMENT_NODE             | 1
        // Text                | Node.TEXT_NODE                | 3
        // Comment             | Node.COMMENT_NODE             | 8
        // Document            | Node.DOCUMENT_NODE            | 9
        // ------------------------------------------------------------------------

        Свойства для навигации по DOM
        // childNodes - массив всех дочерних узлов
        // firstChild - первый дочерний узел
        // lastChild - последний дочерний узел
        // nextSibling - следующий узел расположенный на одном уровне с текущим
        // previousSibling - предыдущий узел расположенный на одном уровне с текущим
        // parentNode - родительский узел для текущего элемента

Свойства объекта window. 

setTimeout (функция, таймаут, параметры для функции) – планирует 
запуск функции, через определенное количество миллисекунд.
setInterval (функция, интервал, параметры для функции ) – похож 
на setTimeout но автоматически заново планирует повторное 
использование метода.-!он запускает выполнение функции не один раз,
 а регулярно повторяет её через указанный интервал времени.
 Остановить исполнение можно вызовом clearInterval(timerId).

Location – объект предоставляет доступ к URL-адресу текущей страницы.
Свойства: protocol, host, path name, search

Navigator – объект с информацией о веб браузере. Свойства: appName ,
 appVersion , userAgent , platform, appCodeName .

Объект Screen содержит информацию о экране пользователя. Свойства: 
width, height, availWidth , availHeight

window.open 
win.close

DOM Level 0 

<p id=“test”></p>
<script> var p = document.getElementById (“test”); p. onclick = function(){} </script>

DOM Level 2

addEventListener (event, handler, capture);
event – имя события. Без приставки ‘on’, например ‘click’, ‘load’,
 но не ‘onclick’, ‘onload ’
handler – функция -обработчик
сapture – true -обработчик срабатывает на этапе перехвата, 
false – обработчик срабатывает на этапе всплывания.

removeEventListener (event, handler, capture); - удаление обработчика
Event.stopPropogation (); - прекращение распространения события.
Event.prevrnDefault (); - отмена действия по умолчанию.
	Для Internet Explorer
attachEvent (event, handler) - установка обработчика
detachEvent (event, handler) - удаление обработчика
event.cancelBubble = true - отмена распространения события 
(только этап всплывания)

Особенности распространения событий в DOM Level 2. 
События проходят через три этапа: 
1. Этап перехвата – событие распространяется от корневого элемента
 (Document) до 
элемента в котором произошло. 
2. Этап обработки в целевом узле – событие происходит в элементе,
 который его 
инициировал. 
3. Этап всплывания – событие поднимается по дереву элементов от 
целевого элемента к 
корневому. 
В модели событий Internet Explorer есть только два этапа обработки 
события – в целевом объекте и всплывание.

stopPropagation() – метод, который можно вызвать на объекте события
 для того что бы 
прекратить его распространение на этапе перехвата или всплывания.
preventDefault() – метод для отмены  действия по умолчанию, 
связанного с событием. Например,
если этот метод вызвать в обработчике события submit формы, 
то браузер не выполнит отправку данных формы на сервер.

form – элемент HTML разметки для отправки данных введенных 
пользователем на 
сервер.

Cookie – небольшой набор данных сохраненных веб-браузером и 
привязанных к определенной странице или сайту. 
Для получения доступа к cookie наборам необходимо выполнить 
инструкцию document . cookie .
· Expires – дата, когда cookie набор будет считаться не 
действительный или max - age время жизни набора в секундах. 
· Path – страница или директория на сайте к которой относятся 
cookie наборы. 
· Domain – позволяет задать субдомены, на который можно будет 
отправлять cookie наборы. 
· Secure – при значении true cookie набор будет отправлен на 
сервер только при HTTPS протоколе.
 4Kb.
Session Storage - Значение существует до тех пор, пока открыта
 вкладка или окно, в которой они сохранены.
Значения видны в окне или вкладке в которой они были созданы.
 5 Mb

var img = new Image(); img.src = “img url”; Данный код заставит 
браузер скачать изображение и поместить его в кэш.

Технологии создания графики на стороне клиента:
· Масштабируемая векторная графика (Scalable Vector Graphics, SVG) 
· Векторный язык разметки (Vector Markup Language, VML)
· HTML элемент <canvas> · Silverlight · Flesh Player
Получение доступа к изображениям в JavaScript сценариях: 
document.images[] – массив с изображениями в том порядке в котором
 они определены в разметке. 

Hyper Text Transfer Protocol(http)
HTTP (Hyper Text Transfer Protocol) – протокол, который определяет 
как веб браузер должен запрашивать документы,
как информация должна передаваться серверам и как веб- сервера 
должны отвечать на веб запросы .

HTTP запрос 
Request
GET - HTTP глагол (метод или команда) описывающая действие, которое 
должен выполнить веб сервер
Host: www.example.com - заголовок. Доменное имя сайта к которому 
выполняется запрос. 
Полезно в том случае если на сервере одновременно работает несколько
 веб приложений
HTTP ответ
Respnse
HTTP/1.1 - версия протокола 
200 - status code 
OK - описание статуса

http-глаголы

OPTIONS-Используется клиентским приложение для получения списка 
глаголов
GET-Получение данных с сервера
HEAD-Получение метаданных(заголовков)ресурса. При данном запросе 
ресурса не возвращается
POST-Отправка данных на сервер для обработку, Обычно данные 
введенные пользователем на странице
PUT-Позволяет клиенту создавать ресурс по указанному URL создать 
файл на сервер
DELETE-Удаление ресурса на сервере
CONNECT-Команда для использования с прокси сервера

Группа статус кодов http

1xx-Информационные
2xx-Успешное завершение
3xx-Команды перенаправлений
4xx-Клиентские ошибки
5xx-Серверные ошибки

Свойства XMLHttpRequest: readyState – Состояние HTTP запроса.
Во время создания объекта инициализируется значением 0 и меняется в
 процессе использования объекта. 
Состояние Имя Описание 
0 Uninitialized Начальное состояние объекта, 
который только что создан или возвращен в это состояние с помощью 
метода abort 
1 Open Метод open() уже вызван но еще не вызван метод send(). 
Запрос 
еще не отправлен. 
2 Start Вызван метод send(). HTTP запрос отправлен серверу но ответ 
еще не получен. 
3 Receiving Все заголовки ответа уже приняты. Продолжается прием тела 
ответа, прием еще нет 
4 Loaded Ответ на запрос полностью получен.

responseText – тело ответа не включая заголовки. Если значение 
свойства 
readyState меньше 3, свойство возвращает ту часть тела, которая 
доступна на данный момент. 
responseXML – ответ на запрос, который интерпретируется как XML 
документ и возвращается в виде объекта Document .
status – HTTP код состояния, например, 200 – в случае успеха, 
404 - в случае отсутствия 
запрашиваемого документа. statusText – Свойство хранит описание 
HTTP кода ответа.
Методы XMLHttpRequest:
Abort() – отменяет исполнение текущего запроса, закрывает соединение
 и прекращает сетевую 
активность. 
getAllResponseHeaders() – возвращает все HTTP -заголовки в виде 
неразобранной строки 
getResponseHeader() – возвращает заголовок с указанным именем. 
open() – инициализирует параметры HTTP запроса. 
send() – отправляет HTTP запрос. 
setReqyestHeader() – устанавливает или добавляет HTTP заголовок.
Обработчики событий XMLHttpRequest : 
onreadystatechange – срабатывает каждый раз когда меняется значения
 свойства readyState .
В зависимости от браузера, может многократно вызываться при значении
 readyState = 3.

IIFE (Immediately Invoked Function Expression ) 
(function(){

})()

<---
Ajax-Asynchronous JavaScript And XML. Модель для запросов данных 
от сервера в фоновом режиме, без перезагрузки веб-страницы.
--->

<---
SPA – это web-приложение, размещенное на одной странице, 
которая для обеспечения работы загружает все javascript-файлы
 (модули, виджиты, контролы и т.д.) , а также файлы 
CSS вместе с загрузкой самой страницы.

модули:(1)
	let app = (function(){
		let todos = [];

		return {
			getTodos: funcrion(){},
			getTodo: function(){},
			addTodo: funcrion(){},
			deleteTodo: function(){}
		};
	})();
	еще можно как свойства обекта:(2)
			let app = (function(){
		let todos = [];
			funcrion getTodos(){},
			function getTodo(){},
			funcrion addTodo(){},
			function deleteTodo(){}

		return {
			getTodos,
			getTodo,
			addTodo,
			deleteTodo
		};
	})();
--->

<---
AMD- Asynchronous module definition(Асинхронное определение модуля)
— это подход к разработке на Javascript, 
который позволяет создавать модули таким образом, чтобы они и их 
зависимости могут быть загружены асинхронно.
 Асинхронная загрузка модулей позволяет улучшить скорость загрузки 
веб страницы в целом, 
так как модули загружаются одновременно с остальным контентом сайта.
Кроме того, AMD может быть использован во время разработки для 
разбиения JavaScript-кода по разным файлам.
Похожее есть и в других языках программирования, например Java, 
которая поддерживает такие ключевые слова,
как import, package и Class.Для продакшена JavaScript-файлы 
рекомендуется соединить и сжать в один маленький файл.

AMD – одна из самых древних систем организации модулей, требует 
лишь наличия клиентской библиотеки, к примеру,
require.js, но поддерживается и серверными средствами.

CommonJS – система модулей, встроенная в сервер Node.JS. Требует 
поддержки на клиентской и серверной стороне.

UMD – система модулей, которая предложена в качестве универсальной.
 UMD-модули будут работать и в системе AMD и в CommonJS.

Все перечисленные выше системы требуют различных библиотек или 
систем сборки для использования.
Новый стандарт отличается от них прежде всего тем, что это – 
стандарт. А значит, со временем,
будет поддерживаться браузерами без дополнительных утилит. Однако,
 сейчас браузерной поддержки почти нет. 
Поэтому ES-модули используются в сочетании с системами сборки, 
такими как webpack, brunch и другими,
подключенном Babel.JS.
--->

Парадигмы JS:
	Императивный и Декларативный подход
	Функциональное программирование

Рекурсия — это важный метод программирования, позволяющий функции 
вызывать саму себя.

<!-- 
React, Redux

Redux — это инструмент управления как состоянием данных,
 так и состоянием интерфейса в JavaScript-приложениях.
 Он подходит для одностраничных приложений, в которых 
управление состоянием может со временем становиться сложным.
 Redux не связан с каким-то определенным фреймворком,
 и хотя разрабатывался для React, может использоваться
 с Angular или jQuery.

React.js — фреймворк для создания интерфейсов от Facebook.
 Он позволяет создавать интерфейсы. В известном паттерне 
Model-View-Controller наш React ближе всего к пользователю.
 Он отвечает за представление данных, получение и 
обработку ввода пользователя. 

-->

Promise – это специальный объект, который содержит свое состояние. 
Вначале pending («ожидание»), 
затем – одно из: fulfilled («выполнено успешно») или rejected 
(«выполнено с ошибкой»).

REST- Representational State Transfer — «передача состояния 
представления»  является архитектурным стилем, в то время как SOAP
 является протоколом. Несмотря на то, что REST не является стандартом
 сам по себе,
большинство RESTful-реализаций используют стандарты, такие как HTTP,
 URL, JSON и XML.
Требования к архитектуре REST Существует шесть обязательных 
ограничений для построения распределенных REST-приложений по 
Филдингу
	1. Модель клиент-сервер
	2. Отсутствие состояния
	3. Кэширование
	4. Единообразие интерфейса
	5. Слои
	6. Код по требованию (необязательное ограничение)

REST — архитектурный стиль взаимодействия компонентов распределённого приложения в сети.
REST представляет собой согласованный набор ограничений, учитываемых при проектировании 
распределённой гипермедиа-системы. 

<--
Раздница между ES5 and ES6
Разница между ES5 and ES6
let var
let- предоставляется для того чтобы объявление переменных 
стали более интуитивным!

например:
var buttons =docement.querySelectorAll('button');
for(var i= 0; i < buttons.length; i++){//в таком варианте будет
//выводится 5
//если поставить let вместо var тогда к каждому кнопке выведется
//свое значение
var button =buttons[i];
buttons.innerText=i;
button.onclick =function(e){
consol.log(i);
 }
}

Оператором разворота(...) или распространения (по-английски 
называется spread operator), который позволяет разворачивать 
элементы массива для передачи в качестве аргументов функции 
или в элементы другого массива.
например:
et staticLanguages = ['C', 'C++', 'Java'];
let dynamicLanguages = ['JavaScript', 'PHP', 'Ruby'];

let languages = [...staticLanguages, 'C#', ...dynamicLanguages, 'Python'];

console.log(languages);
//вывод консоли: (8) ["C", "C++", "Java", "C#", "JavaScript", "PHP", "Ruby", "Python"]
function add(x, y, z) {
    console.log(x + y + z);
	//вывод консоли: 6
}

let numbers = [1, 2 ,3];

add(...numbers);

Шаблонные строки (template strings)


-->

** выше — цитаты из курса SaaS на coursera.

— BDD:
Слово Driven в BDD означает, что behaviour (выраженные в виде user stories) 
ведут вашу разработку. И вы разрабатываете именно те фичи, которые нужны заказчику.
В итоге одной user story соответствует Acceptance test.
Т.е. сначала пишете список user stories, потом их реализуете, показываете заказчику,
 потом берете следующие user stories и их реализуете, показываете и т.д.. 
Это тесно связано с методологией Agile Development.

— TDD
Ключевое слово Driven в TDD означает, что сначала пишется тест (который задает,
 что должно быть и как должна работать система), а потом уже пишется код.
Т.е. TDD — это не набор определенных тестов, это — методология (стиль) процесса разработки.
Точно так же BDD — это не набор определенных тестов, это идея процесса разработки,
 часть которого — написание тестов.

Если вы вначале пишете весь код, а потом перед сдачей проекта пишет набор тестов
 (которые могут и не покрыть все 100% кода) — то это не TDD.

— Процесс разработки
Если вы узнали требования от заказчика или прочитав спецификацию, и начали создание
 системы с написания кода (классов, сервисов, структуры базы данных). 
Потом вы пообщались с заказчиком, уточнили требования, или поменялась спецификация,
 и после этого вы поменяли свой код.
И тут пришло время сдавать проект и вы решили писать тесты...
То это не имеет никакого отношения к TDD и BDD.

-->

<--
Set, Map, WeakSet и WeakMap
В ES-2015 появились новые типы коллекций в JavaScript: Set, Map,
WeakSet и WeakMap.

Map – коллекция для хранения записей вида ключ:значение.
В отличие от объектов, в которых ключами могут быть только строки,
в Map ключом может быть произвольное значение, например:

Set – коллекция для хранения множества значений, 
причём каждое значение может встречаться лишь один раз.
Например, к нам приходят посетители, и мы хотели бы сохранять всех,
кто пришёл. При этом повторные визиты не должны приводить к дубликатам, 
то есть каждого посетителя нужно «посчитать» ровно один раз.

-->

