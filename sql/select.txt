Элементы
Язык SQL представляет собой совокупность операторов, инструкций, вычисляемых функций.

Согласно общепринятому стилю программирования, операторы (и другие зарезервированные слова) в
 SQL обычно рекомендуется писать прописными буквами[9].

Операторы SQL делятся на:
***
операторы определения данных (Data Definition Language, DDL):
CREATE- создаёт объект базы данных (саму базу, таблицу, представление, пользователя и так далее),
ALTER- изменяет объект,
DROP- удаляет объект;
***
операторы манипуляции данными (Data Manipulation Language, DML):
SELECT- выбирает данные, удовлетворяющие заданным условиям,
INSERT- добавляет новые данные,
UPDATE- изменяет существующие данные,
DELETE- удаляет данные;
***
операторы определения доступа к данным (Data Control Language, DCL):
GRANT- предоставляет пользователю (группе) разрешения на определённые операции с объектом,
REVOKE -отзывает ранее выданные разрешения,
DENY- задаёт запрет, имеющий приоритет над разрешением;
операторы управления транзакциями (Transaction Control Language, TCL):
COMMIT- применяет транзакцию,
ROLLBACK- откатывает все изменения, сделанные в контексте текущей транзакции,
SAVEPOINT- делит транзакцию на более мелкие участки.
CRUD- (сокр. от англ. create, read, update, delete — «создать,
 прочесть, обновить, удалить»). 
***
SELECT названия нужных полей FROM название таблицы WHERE условие выборки 

SELECT- Инструкция которая извлекает информацию из базы данных
Например:
SELECT NAME, SALES, QUATA, (SALES - QUOTA)
	FROM SALESREPS// Вычисляется сумма котораю делает каждый из операторов по продаже!
INSERT -  Добавляет данные в соответствующую таблицу данных
Например: INSERT INTO OFFICES (CITY, REGION, TARGET, SALES, OFFICE)
		VALUES(‘Dallas’, ‘Western’, 275000.00, 0.00, 23)
row inserted.

DELETE -Удаляет данные из таблицы
Например:
DELETE FROM CUSTOMERS
  where company = ’ Acme Industries ’//Где  Acme Industries название удаляемой компании из базы данных.
row deleted


UPDATE- Обновление данных в СУБД
CREATE TABLE- Определяет новую таблицу для данных о товаре

LEFT JOIN
Возвращаются все данные из «левой» таблицы, даже если не найдено соответствий в «правой» таблице 
(«левая» таблица в SQL-запросе стоит левее знака равно, «правая» — правее, то есть обычная логика правой и левой руки).
 Иными словами, если мы присоединяем к «левой» таблице «правую», то выберутся все записи в соответствии с условиями 
WHERE для левой таблицы. Если в «правой» таблице не было соответствий по ключам, они будут возвращены как NULL. 
Таким образом, здесь главной выступает «левая» таблица, и относительно нее идет выдача. В условии ON «левая» таблица
 прописывается первой по порядку (table_01), а «правая» – второй (table_02):
RIGHT JOIN
Возвращаются все данные из «правой» таблицы, даже если не найдено соответствий в «левой» таблице. То есть примерно также,
 как и в LEFT JOIN, только NULL вернется для полей «левой» таблицы. Грубо говоря, эта выборка ставит во главу угла правую
 «таблицу», относительно нее идет выдача. Обратите внимание на WHERE в следующем примере, условие выборки затрагивает 
«правую» таблицу:

Логические операторы:
AND логическое "И"
OR логическое "ИЛИ"
NOT логическое отрицание

= Равно
> Больше чем
< Меньше чем
>= Больше или равно
<= Меньше или равно
<> Не равно


operator
Назначение
All
TRUE, если все сравнения в наборе равны TRUE.
And
TRUE, если оба выражения типа Boolean равны TRUE.
ANY
TRUE, если любое из сравнений в наборе равно TRUE.
Between
TRUE, если операнд принадлежит указанному диапазону.
EXISTS
TRUE, если вложенный запрос возвращает как минимум одну строку.
In
TRUE, если операнд содержится в заданном списке выражений.
LIKE
TRUE, если оператор удовлетворяет шаблону.
NOT
Меняет значение оператора типа Boolean на противоположное.
Or
TRUE, если одно из выражений типа Boolean равно TRUE.
SOME
TRUE, если некоторые из сравнений в наборе равны TRUE.

with 
insert into t1(id)
with t as
(select 1 from dual),
t1 as
(select * from t),
t2 as
(select * from t1)
select * from t2

select 
a.OutletCode, 
a.ProductID, 
LatestDate,
 MIN(Cost) AS MinPrice 

from 
( 
SELECT MAX(CostingDate) AS LatestDate, 
OutletCode, ProductID 
FROM AccountsCosting 
WHERE OutletCode = 'C&T01' 
GROUP BY OutletCode, ProductID 
) a 
left join 
FROM AccountsCosting b 
on 
a.OutletCode=b.OutletCode 
and a.ProductID=b.ProductID 
and a.LatestDate=b.CostingDate 
group by a.OutletCode, a.ProductID, LatestDate



ORDER BY sum(esr.rest) DESC ASC
1- SELECT * FROM Customers;
//Данным запросом мы выведим все данные по базе Customers

2- SELECT CustomerName,City FROM Customers;
//Следующее утверждение SQL выбирает "CustomerName" и колонки "City" из "Customers" 

3- SELECT DISTINCT Address FROM Customers;
//достает из базы данные только с ячейки Address 
//Из базы Customers мы достаем все данные конторы есть в ячейке  address

4- SELECT * FROM Customers WHERE Country='Mexico';
// из базы  Customers  выберает ТОЛЬКО! ячейку Country и только страну 'Mexico'
выведет все данные по 'Mexico'

4(b)- SELECT * FROM Customers WHERE CustomerID=14;
//вытягиваем из базы Customers   с ячеки CustomerID строку под пом ее номеру 14

5- SELECT * FROM Customers WHERE Country='Germany' AND City='Berlin';
// выводит из базы Customers   только данные по Берлину тут акцент на AND “и”

6- SELECT * FROM Customers WHERE City='Berlin' OR City='Mьnchen';
//выбирает всех клиентов из города "Берлин" ИЛИ "Munchen", в "Customers" таблицы. 

7- SELECT * FROM Customers WHERE Country='Germany' AND (City='Berlin' OR City='Munchen');
//выбирает все клиенты из страны "Германия" И город должен быть равен "Берлин" ИЛИ "Munchen", в "Customers"

8- SELECT * FROM Customers ORDER BY Country DESC;
//SQL выбирает всех клиентов из «клиентов» таблицы, отсортированные по колонке "Country"

9-SELECT Orders.OrderID, Customers.CustomerName, Orders.OrderDate
FROM Orders
INNER JOIN Customers0
ON Orders.CustomerID=Customers.CustomerID;

SELECT Customers.CustomerName, Orders.OrderID--с баз и ячеек с каторых --тяним данные(Customers-база CustomerName-ячейка. Orders-База --OrderID-ячейка)
FROM Customers --База Customers с нее тянем
LEFT JOIN Orders-- База добовляем в Customers 


ON Customers.CustomerID=Orders.CustomerID--тут сравневаються два столбца --CustomerID из Customers и CustomerID из Orders
--выводет имя клиента и OrderID


//LEFT JOIN ключевое слово возвращает все строки из левой таблицы (Customers), даже если нет никаких матчей в правой таблице (Orders).

ORDER BY Customers.CustomerName; --и сортеруеться 
//скачало выгрузит данные с базы Customers с ячейки CustomerName
и затем выгрузит данные с базы Orders с ячеки OrderID
9-б 
	Inner join необходим для получения только тех строк, для которых существует соответствие записей главной таблицы и присоединяемой.

-10 SELECT * FROM Customers
WHERE City LIKE 's%';
// выбирает с базы Customers колонку City  в которой находятся данные с заголовком с первой буквой s*

SELECT * FROM Customers
WHERE City LIKE '[bsp]%';
// выбирает с колонки City  только данные с заглавием b s p все названия городов с началом b s p например Berlin, Strasbourg, Portland 

SELECT * FROM Customers
WHERE City LIKE '[a-c]%';
//выберает все города с a по c.
	
			SELECT * FROM Customers
WHERE City LIKE '[!bsp]%'; --знак нет

SELECT * FROM Customers
WHERE City NOT LIKE '[bsp]%'; --словом нет NO

//небудет выводить данные в колонке City и именами наченающие с bsp два запроса оденаковы просто запесь разная!


11- SELECT * FROM Customers
WHERE City IN ('Paris','London');
// позволяет вывести с ечейки все данные по двум ячейкам Paris, London

12- SELECT * FROM Products
WHERE Price BETWEEN 10 AND 20; --BETWEEN  между
//выберет все продукты с ценой от 10до  20 небольше

SELECT * FROM Products -- база
WHERE (Price BETWEEN 10 AND 20) --где вытаскиваем стобец Price с данными от 10 до 20  тоесть все деньги выведит от 10 до 20
AND NOT CategoryID IN (1,2,3); -- не высадить в колонке CategoryID значения начинающие с 1,2,3 -все остальное выведет как обычно

SELECT * FROM Products
WHERE ProductName BETWEEN 'C' AND 'M';
	//Следующее утверждение SQL выбирает все продукты с ProductName, начиная с любого из письма МЕЖДУ 'C' и 'M'
SELECT * FROM Products
WHERE ProductName NOT BETWEEN 'C' AND 'M';
//Следующее утверждение SQL выбирает все продукты с ProductName начиная с любого из письма не между 'C' и 'M':

13- SELECT  CustomerName AS Customer, ContactName AS [Contact Person]
FROM Customers;
//В следующем SQL оператор задает два псевдонима: один для столбца CustomerName и один для ContactName колонке. Совет: Это требует двойные кавычки или квадратные скобки, если имя столбца содержит пробелы:

SELECT CustomerName, Address+', '+City+', '+PostalCode+', '+Country AS Address
FROM Customers;

//В следующем заявлении SQL мы объединяем четыре колонки (адрес, город, PostalCode, и страна) и создать псевдоним с именем "Адрес":

14- SELECT o.OrderID, o.OrderDate, c.CustomerName --посуте вместо c --подстовляеться база Customers 
FROM Customers AS c, Orders AS o
WHERE c.CustomerName="Around the Horn" AND c.CustomerID=o.CustomerID;
//В следующем SQL оператор выбирает все заказы от клиента с CustomerID = 4 . Мы используем «Клиенты» и «Заказы» таблицы, и дать им псевдонимы таблиц "С" и "О" соответственно (Здесь мы использовали псевдонимы, чтобы сделать SQL короче):

15-
CASE 
CASE <проверяемое выражение>
WHEN <сравниваемое выражение 1>
THEN <возвращаемое значение 1>
…
WHEN <сравниваемое выражение N>
THEN <возвращаемое значение N>
[ELSE <возвращаемое значение>]
END
2-я форма:
CASE
WHEN <предикат 1>
THEN <возвращаемое значение 1>
…
WHEN <предикат N>
THEN <возвращаемое значение N>
[ELSE <возвращаемое значение>]
END


//////////////////////////////////////
Что такое первичный ключ?
 
В теории реляционных баз данных логическая группировка элементов данных называется «отношением», а определенный экземпляр
 отношения - «кортежем». Так вот первичный ключ — это множество атрибутов отношения, которое уникально определяет кортеж 
этого отношения.
 
На практике первичный ключ означает определенный набор столбцов таблицы, который уникально идентифицирует каждую строку.
 Первичный ключ может состоять как из одного столбца, так и из нескольких.
 
Например, рассмотрим таблицу заказов, состоящую из столбцов:
 
order_id (уникальный номер заказа — первичный ключ)
order_date (дата совершения заказа)
order_customer (покупатель, сделавший покупку)
order_sum (сумма заказа).
В этой таблице столбец order_id является первичным ключом и уникально определяет каждую строку таблицы, т.е. заказ.
 
 
Что такое внешний ключ?
 
Когда поле таблицы ссылается на другое поле в другой таблице, оно называется внешним ключом. Поле, на которое он ссылается,
 является первичным ключом.
 
Например, в таблице заказов, очевидно, должно быть поле order_customer, которое определяет покупателя сделавшего покупку.
Мы могли бы в это поле записывать просто ФИО покупателя. Но как быть, если нам нужно выбрать все заказы, сделанные
 конкретным покупателем? Велика вероятность, что в таблице могут находится люди, у которых полностью совпадает ФИО.
 
Во избежание подобных проблем (примеров можно придумать массу) в поле order_customer необходимо хранить внешний ключ,
 который будет ссылаться на первичный ключ в таблице customers (покупатели).
 
Например, в таблице заказов будет строка, где в поле order_customer содержится внешний ключ — 3246. Далее в таблице
 customers необходимо отыскать строку с первичным ключом, равным 3246, в этой строке и будут содержаться все данные
 покупателя, включая и ФИО.
 
 
Что такое нормализация БД?
 
Процесс приведения базы данных к виду, в котором она будет соответствовать правилам нормальных форм, называется 
нормализацией базы данных.
 
Нормализация базы данных сводит к минимуму количество избыточной информации. Ее целью является сохранять данные 
только один раз, но в нужном месте.
 
Нормализованная база данных исключает дублирование и многократное обслуживание данных, а также появление проблем 
с целостностью данных, возникающих при повторном вводе одинаковых данных.
 
Первоначально доктором Эдгаром Коддом были определены только 3 нормальные формы. Дальнейшая разработка реляционной 
теории привела к появлению еще нескольких форм и на данный момент их насчитывается 6.
 
На практике соответствие базы данных правилам 3-ей нормальной формы вполне достаточно.
 
 
Что такое денормализация БД? Для чего она нужна?
 
Денормализация — это процесс осознанного приведения базы данных к виду, в котором она не будет соответствовать 
правилам нормализации. Обычно это необходимо для повышения производительности и скорости извлечения данных, 
за счет увеличения избыточности данных.
 
Если приложению необходимо часто выполнять выборки, которые занимают слишком много времени (например, объединение
 данных из множества таблиц), то следует рассмотреть возможность проведения денормализации.
 
Возможное решение следующее: вынести результаты выборки в отдельную таблицу. Это позволит увеличить скорость 
выполнения запросов, но также означает появление необходимости в постоянном обслуживании этой новой таблицы.
 
Прежде чем приступать к денормализации, необходимо убедится, что ожидаемые результаты оправдывают издержки, 
с которыми придется столкнуться.
 
 
Что такое кластерный и некластерный индекс?
 
Индексы делятся на 2 вида — кластерный и некластерный.
 
Обычно СУБД хранит строки в том порядке, в котором они добавляются в таблицу.
 
Кластерный индекс предлагает собой способ хранения строк таблицы так, что их действительное хранение связано 
с логическими значениями в некоторых столбцах. В кластере могут содержаться либо строки из одной таблицы, 
либо связанные между собой строки из нескольких таблиц.
 
Некластерный индекс хранит указатели на строки в таблице. Такой способ хранения подразумевает после обращения 
к индексу обращение к самой таблице для получения строк.
 
Наиболее часто используемые типы индексов:
B-деревья
Хеши
R-деревья
Полнотекстовые
В отличие от некластерного индекса, таблица может иметь только один кластерный индекс.
 
 
Какие типы соединений (join) таблиц существуют? В чем их разница?
 
Существуют следующие типы соединений таблиц:
INNER JOIN
FULL OUTER JOIN
LEFT OUTER JOIN
RIGHT OUTER JOIN
CROSS JOIN
Опишем каждый тип соединений на примере запросов. Рассмотрим 2 таблицы A и B:
 
A:
ID   NAME
1	Вася
2	Петя
3	Федя
4	Маша
 
B:
ID   NAME
1	Иван
2	Вася
3	Лена
4	Федя
Посмотрим на результаты следующих запросов:
 
SELECT * FROM A INNER JOIN B ON A.NAME = B.NAME
ID   NAME ID   NAME
1	Вася 2	Вася
3	Федя 4	Федя
 
SELECT * FROM A FULL OUTER JOIN B ON A.NAME = B.NAME
ID   NAME ID   NAME
1	Вася 2	Вася
2	Петя null null
3	Федя 4	Федя
4	Маша null null
null null 1	Иван
null null 3	Лена
 
SELECT * FROM A LEFT OUTER JOIN B ON A.NAME = B.NAME
ID   NAME ID   NAME
1	Вася 2	Вася
2	Петя null null
3	Федя 4	Федя
4	Маша null null
 
SELECT * FROM A RIGHT OUTER JOIN B ON A.NAME = B.NAME
ID   NAME ID   NAME
3	Федя 4	Федя
null nul  3	Лена
1	Вася 2	Вася
null null 1	Ivan
 
SELECT * FROM A CROSS JOIN B
4	Masha 4	Fedya
3	Fedya 4	Fedya
2	Petya 4	Fedya
1	Vasya 4	Fedya
4	Masha 3	Lena
3	Fedya 3	Lena
2	Petya 3	Lena
1	Vasya 3	Lena
4	Masha 2	Vasya
3	Fedya 2	Vasya
2	Petya 2	Vasya
1	Vasya 2	Vasya
4	Masha 1	Ivan
3	Fedya 1	Ivan
2	Petya 1	Ivan
1	Vasya 1	Ivan
CROSS JOIN является полным декартовым произведением, т.е. возвращает все возможные сочетания записей таблиц A и B. 
В стандартном SQL CROSS JOIN выполняется без условия ON, однако, например, в MySQL этого ограничения нет и CROSS 
JOIN является аналогом INNER JOIN.
 
 
Что такое SQL курсор?
 
Иногда бывает нужно в результирующем наборе SQL-запроса обрабатывать строки по одной. Для этого обычно используются 
циклы и объект, называемый курсором.
 
SQL курсор можно представить как указатель в результирующем наборе. Его можно перемещать, обрабатывая каждую строку,
 пока не закончится результирующий набор.
 
 
Опишите шаги по созданию и использованию курсора?
 
Продемонстрируем использование курсора на простом примере:
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
CURSOR cselectitem
IS
 	SELECT id, name FROM items; /* Объявляем курсор, привязывая к нему SQL — запрос. */
BEGIN
 	OPEN cselectitem; /* Далее перед использованием курсор необходимо открыть */
 	LOOP
       	FETCH cselectitem
            	INTO item_id, item_name; /* В цикле вытаскиваем каждую строку,
                                                    используя конструкцию FETCH, и  значения
                                                    полей выборки записываем в переменные,
                                                    которые должны быть заранее объявлены */
       	EXIT WHEN cselectitem%NOTFOUND; /*  Выходим из цикла, когда достигнут конец
                                                    результирующего набора */
 	END LOOP;
 
 	CLOSE cselectitem; /* Закрываем курсор */
END
 
Что такое транзакция?
 
По определению, транзакция — это логическая единица работы.
 
Транзакция предполагает, что все, входящие в нее SQL-запросы будут обязательно выполнены, причем одновременно.
 
Начать транзакцию можно при помощи команды BEGIN TRANSACTION. Завершить можно либо сохранив изменения в базе 
данных при помощи команды COMMIT, либо удалив все сделанные транзакцией изменения командой ROLLBACK
 
Приведем пример транзакции, которая снимает деньги с одного пользовательского счета и переводит их на другой:
1
2
3
4
5
6
BEGIN TRANSACTION
UPDATE user_account SET balance=balance-100 WHERE account_id=1 /* Снимаем деньги со счета,
                                           	                   ID которого равен 1 */
UPDATE user_account SET balance=balance+100 WHERE account_id=2 /* И переводим эти деньги на
                                                                  счет, ID которого равен 2 */
COMMIT
Понятно какие-бы проблемы могли бы возникнуть, если бы одна часть этой транзакции была бы выполнена успешно, 
а другая нет. Однако использование транзакций не допускает подобных ситуаций.
 
При работе с транзакциями возможны 2 варианта:
результаты выполнения всех запросов, входящих в транзакцию, будут применены к базе данных
все внесенные изменения в базу данных будут отменены (откатаны).
Пока результаты выполнения запросов, входящих в транзакцию не будет применены к базе данных при помощи оператора 
COMMIT, они остаются невидимы для других пользователей базы данных.
 
 
Что такое блокировка?
 
Существует 2 вида взаимодействий с базой данных, которые требуют блокировки 2-х разных типов:
Разделяемая блокировка
Когда пользователь считывает данные, его совершенно не волнует кто эти данные считывает еще.
При подобных операциях на данные накладывается разделяемая блокировка, которая говорит о том, что любая транзакция
 может выполнять эту же операцию с данными, т.к. она не изменяет их и не сможет привести ни к каким побочным эффектам.
Монопольная блокировка
В случае, если выполняемая операция изменяет данные, на них накладывается монопольная блокировка, которая позволяет
 изменять данные только одному пользователю.
СУБД не может устанавливать монопольную блокировку на данные, на которые уже установлена разделяемая блокировка. 
Такое ограничение имеет смысл как для пользователя, который записывает данные, так и для пользователя, который их считывает.
 
Что такое deadlock?
 
Взаимная блокировка (или deadlock) — это ситуация, при которой возник конфликт между несколькими операциями записи.
 
Рассмотрим пример:
Операция 1 Операция 2
Необходимо изменить данные A и B
Происходит изменение данных A  
 	Происходит изменение данных B
 	Ожидание снятия блокировки с данных A
Ожидание снятия блокировки с данных B
В описанном примере обе операции могут снять блокировку с данных только после полного завершения своей работы. 
Но для завершения работы операции 1 нужно снятие блокировки с данных B, а для операции 2 снятие блокировки с данных
 A. Обе операции вступают в бесконечное ожидание снятия блокировки с данных.
 
Обойти эту проблему никак нельзя, поскольку СУБД не может разрешить двум операциям вносить изменения в один 
и тот же фрагмент данных одновременно, не потеряв при этом весь контроль над целостностью данных.
 
Поскольку исключить потенциальную возможность возникновения взаимных блокировок нельзя, лучшее решение — 
это уменьшить промежуток времени, во время которого взаимная блокировка может произойти.
 
Другими словами команда COMMIT должна выполняться сразу, как только операция записи станет возможна, для 
сокращения времени, в течение которого данные заблокированы.
 
 
Что такое триггер? (Какие типы триггеров вы знаете?)
 
Триггеры — это части кода, запускаемые автоматически и основанные на каком-либо действии или событии в таблице
 базы данных.
 
Триггеры могут применять в таблице во время выполнения операторов INSERT, UPDATE или DELETE, а затем работать
 или перед, или после этих действий.
 
Некоторые СУБД также позволяют работать триггерам на уровне оператора или на уровне каждой строки данных во
 время ее изменения.
 
 
В чем разница между WHERE и HAVING?
 
Конструкцию HAVING можно использовать только при наличии конструкции GROUP BY. Она действует по отношению
 к результатам конструкции GROUP BY аналогично тому, как конструкция WHERE отсеивает строки, возвращаемые
 оператором SELECT, в соответствии с указанным условием.
 
 
Что такое подзапрос (sub-query)?
 
Подзапрос — это запрос, вложенный в другой запрос.
 
Несколько примеров подзапросов:
1
2
3
4
SELECT * FROM tableA WHERE id IN (SELECT id FROM tableB)
SELECT * FROM tableA WHERE id > (SELECT AVG(id) FROM tableA)
SELECT tA.* FROM (SELECT * FROM tableA WHERE col IS NOT NULL) tA, tableB tB
WHERE tA.id=tB.id

